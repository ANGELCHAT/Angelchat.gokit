package cqrs

import (
	"reflect"

	"github.com/google/uuid"
	"github.com/sokool/gokit/cqrs/es"
	"github.com/sokool/gokit/cqrs/snapshotter"
	"github.com/sokool/gokit/locker"
	"github.com/sokool/gokit/log"
)

type Response struct {
	ID      string
	Version uint
	Error   error
}

type EventSourced struct {
	factory     FactoryFunc
	opts        *Options
	eventStore  *es.Service
	snapshotter *snaps
	access      *locker.Key
	cache       *cache
}

func (s *EventSourced) Send(c Command, aggregate ...string) Response {
	log.Debug("\ncqrs.service", "received %s command", reflect.TypeOf(c).String())
	var id string
	var a *Aggregate
	//var fromVersion uint

	// check if aggregate ID is given
	if len(aggregate) > 0 {
		id = aggregate[0]
	}

	// only one command can change aggregate state at the same time.
	// changing state per aggregate is transactional
	if len(id) > 0 {
		s.access.Lock(id)
		defer s.access.Unlock(id)
	}

	// load aggregate from cache
	if s.cache != nil {
		var ok bool
		a, ok = s.cache.restore(id)
		if ok {
			log.Debug("cqrs.service", "restoring aggregate #%s from cache ", id[24:])
		}

		return s.send(a, c)

	}

	if s.snapshotter != nil && len(id) > 0 { // or restore aggregate from snapshoter
		a = s.factory(id, 0)
		if err := s.snapshotter.restore(a); err != nil {
			return Response{ID: id, Version: 0, Error: err}
		}

		return s.send(a, c)
	}

	// load aggregate events from scratch.
	if len(id) > 0 {
		log.Debug("cqrs.service", "loading events from scratch")
		//evet, err := s.eventStore.Events(id, 0)
		//if err != nil {
		//	return Response{ID: id, Version: 0, Error: err}
		//}

		events, version, err := s.eventStore.Load(id, 0)
		if err != nil {
			return Response{ID: id, Version: version, Error: err}
		}

		// apply all events from storage| rebuild aggregate state
		a = s.factory(id, version)
		a.ID = id
		a.Version = version
		a.events = events
		a.apply()
		a.events = []interface{}{}

		return s.send(a, c)
	}

	log.Debug("cqrs.service", "create new aggregate from factory")
	id = uuid.New().String()
	a = s.factory(id, 0)
	a.ID = id
	a.Version = 0

	return s.send(a, c)
	//}

	//// when aggregate ID is given and not loaded from cache
	//if len(id) > 0 && a == nil {
	//	// load aggregate from storage
	//	//log.Debug("cqrs.service", "loading aggregate from storage #%s", id[24:])
	//	//r, err := s.store.Aggregate(id)
	//	//if err != nil {
	//	//	return a.ID, err
	//	//}
	//	//
	//	//log.Debug("cqrs.service", "creating aggregate id:%s, version:%d", r.ID[24:], r.Version)
	//	//a = s.factory(r.ID, r.Version)
	//
	//	if s.snapshotter != nil {
	//		var err error
	//		log.Debug("cqrs.service", "restore from snapshot")
	//		fromVersion, err = s.snapshotter.restore(a)
	//		if err != nil {
	//			return id, err
	//		}
	//	}
	//
	//
	//
	//}
	//if a == nil {
	//	//todo generate id?
	//	log.Debug("cqrs.service", "create new aggregate from factory")
	//	a = s.factory("", 0)
	//}
	//

	//// send events to listeners of aggregate
	//if s.opts.Handlers != nil {
	//	for _, eh := range s.opts.Handlers {
	//		eh(aggregate, events, r.events)
	//	}
	//}

	return s.send(a, c)
}

func (s *EventSourced) send(a *Aggregate, c Command) Response {
	// dispatch command
	defer func() { a.events = make([]interface{}, 0) }()
	var err error

	if err := a.dispatch(c); err != nil {
		return Response{ID: a.ID, Version: a.Version, Error: err}
	}

	// apply all the events generated by command
	a.apply()

	// persist aggregate and new events in storage
	a.Version, err = s.eventStore.Save(a.ID, a.Name, a.events...)
	if err != nil {
		return Response{ID: a.ID, Version: a.Version, Error: err}
	}

	if s.cache != nil {
		log.Debug("cqrs.service", "storing in cache")
		s.cache.store(a)
	}

	return Response{ID: a.ID, Version: a.Version, Error: err}
}

func NewEventSourced(f FactoryFunc, s *es.Service, os ...Option) *EventSourced {
	o := newOptions(os...)
	r := &EventSourced{
		access:     locker.NewKey(),
		opts:       o,
		eventStore: s,
		factory:    f,
	}

	//if options.SnapEpoch > 0 && options.SnapFrequency > 0 {
	//	r.snapshotter = newSnapshotter(options.SnapEpoch, r.store, f)
	//	go r.snapshotter.run(options.SnapFrequency)
	//}

	if o.Cache {
		r.cache = newCache()
	}

	if o.SnapEpoch > 0 {
		snap := f("", 0).TakeSnapshot()
		z := snapshotter.NewRepository(snap, snapshotter.NewMemoryStorage())
		r.snapshotter = newSnapshotter(s, z)
	}

	return r
}

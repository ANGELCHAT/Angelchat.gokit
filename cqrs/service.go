package cqrs

import (
	"reflect"

	"github.com/sokool/gokit/log"
)

type Service struct {
	factory     FactoryFunc
	opts        *Options
	snapshotter *snapshotter

	cache  *cache
	events *events
}

func (s *Service) Send(c Command, aggregate ...string) (string, error) {
	log.Debug("\ncqrs.service", "received %s command", reflect.TypeOf(c).String())
	var id string
	var a *Aggregate
	var loadFrom uint

	// check if aggregate ID is given
	if len(aggregate) > 0 {
		id = aggregate[0]
	}

	// load aggregate from cache
	if s.cache != nil {
		var ok bool
		a, ok = s.cache.restore(id)
		if ok {
			log.Debug("cqrs.service", "restoring aggregate #%s from cache ", id[24:])
		}
	}

	// when aggregate ID is given and not loaded from cache
	if len(id) > 0 && a == nil {
		// load aggregate from storage
		log.Debug("cqrs.service", "loading aggregate from storage #%s", id[24:])
		r, err := s.opts.Store.Load(id)
		if err != nil {
			return a.ID, err
		}

		log.Debug("cqrs.service", "creating aggregate id:%s, version:%d", r.ID[24:], r.Version)
		a = s.factory(r.ID, r.Version)

		// or restore aggregate from snapshoter
		if s.snapshotter != nil {
			var err error
			log.Debug("cqrs.service", "restore from snapshot")
			loadFrom, err = s.snapshotter.restore(a)
			if err != nil {
				return a.ID, err
			}
		}

		// load aggregate events from given version.
		log.Debug("cqrs.service", "loading events from %d", loadFrom)
		_, err = s.events.load(a, loadFrom)
		if err != nil {
			return a.ID, err
		}

	}
	if a == nil {
		//todo generate id?
		log.Debug("cqrs.service", "create new aggregate from factory")
		a = s.factory("", 0)
	}

	// dispatch command
	log.Debug("cqrs.service", "dispatching command")
	if err := a.dispatch(c); err != nil {
		return id, err
	}

	// apply all the events generated by command
	log.Debug("cqrs.service", "applying %d events", len(a.events))
	for _, e := range a.events {
		a.apply(e)
	}

	// persist aggregate and new events in storage
	events, err := s.events.save(a)
	id = a.ID
	if err != nil {
		return id, err
	}

	if s.cache != nil {
		log.Debug("cqrs.service", "storing in cache")
		s.cache.store(a)
	}

	log.Debug("cqrs.service", "%s saved with %d new events", a.String(), events)

	// send events to listeners of aggregate
	//if s.opts.Handlers != nil {
	//	for _, eh := range s.opts.Handlers {
	//		eh(aggregate, events, r.events)
	//	}
	//}

	return id, nil
}

func NewService(f FactoryFunc, os ...Option) *Service {

	options := newOptions(os...)

	es := []Event2{}
	for e := range f("", 0).Events {
		es = append(es, e)
	}

	r := &Service{
		opts:    options,
		factory: f,
		events: &events{
			store:      options.Store,
			serializer: newSerializer(es...),
		},
	}

	if options.SnapEpoch > 0 && options.SnapFrequency > 0 {
		r.snapshotter = newSnapshotter(options.SnapEpoch, r.events, f)
		go r.snapshotter.run(options.SnapFrequency)
	}

	if options.Cache {
		r.cache = newCache()
	}

	return r
}
